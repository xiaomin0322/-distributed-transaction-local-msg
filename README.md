# distributed-transaction-local-msg-table-implementation
基于本地消息表加mq实现可靠分布式事物


实现封装思路：


基于ebay分布式事物，本地消息表+mq实现分布式事物封装


1.讲本地消息表+mq 封装成功单独的服务，用户开箱即用

资料参考：https://my.oschina.net/xiaominmin/blog/1617147




封装思路：

1.提供一个分布式事物中间件服务对外开放

封装详细信息：
协议:http,tcp
分布式事物事件表：event_publish（事件表）字段:  事件id,事件类型,事件状态(准备状态,准备就系状态,消息发送状态，已发送状态,成功消费状态,异常消费状态)
发送消息扫描定时程序: 扫描事件状态为（准备就系状态，异常消费状态） 发送mq 并且 修改事件状态为：（已发送状态）
回调生产者定时扫描程序：扫描事件状态为:(准备状态)并且超过了指定时间。回调生产者的接口。(比如：消息生产者，提交完本地事物，刚好断电了。需要回调生产者做出相关处理)


服务端是一个独立的部署程序
客户端需要一个client.jar封装一些东西包括:spring aop ，服务调用，生产者回调


分布式事物流程：

1.消息生产者(业务端通过spring aop 拦截参数调用服务接口往事件表插入数据)
1.1方法开始调用服务插入事件表。(事件状态为：准备状态)
1.2方法结束调用服务插入事件表。(事件状态为：准备就绪状态)
1.3回调生产者定时扫描程序(如果执行完1.1后宕机了，会回调生产者回调接口)



2.分布式事物中间件
2.1分布式事物服务扫描定时程序发送mq


3.消息消费者
3.1.接受到消息先调用分布式事物服务，判断该消息在事物事件表中的状态是不是（已发送状态）如果是已发送状态则继续处理。(如果不是已发送状态则表示状态对不上)
3.2.处理消息
3.3.根据处理结果，调用分布式事物服务修改事件表状态：（成功消费状态,异常消费状态）。



对比rocketmq,相当于把rocketmq事物部分功能抽取出来了。
比较：
1.性能方面主要在于数据库，可以用nosql那就没问题
2.可以用其他的mq中间件实现，不局限于某一种中间件





